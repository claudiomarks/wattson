#!/usr/bin/env python3
"""
Wattson API - Enhanced battery management with web API and power monitoring
"""

import os
import time
import json
import yaml
import logging
import argparse
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from dataclasses import dataclass, asdict
from pathlib import Path
import subprocess

from flask import Flask, jsonify, request
from flask_cors import CORS
import threading

@dataclass
class BatteryStatus:
    capacity: int
    status: str  # Charging, Discharging, Full, etc.
    voltage_now: Optional[float] = None
    current_now: Optional[float] = None
    power_now: Optional[float] = None  # Watts
    energy_now: Optional[float] = None
    energy_full: Optional[float] = None
    charge_control_end_threshold: Optional[int] = None
    timestamp: str = None

@dataclass
class PowerMetrics:
    cpu_power: Optional[float] = None  # Watts
    gpu_power: Optional[float] = None  # Watts
    total_system_power: Optional[float] = None  # Watts
    timestamp: str = None

class WattsonAPI:
    def __init__(self, config_path: str):
        self.config = self._load_config(config_path)
        self.setup_logging()
        self.battery_history: List[BatteryStatus] = []
        self.power_history: List[PowerMetrics] = []
        self.max_history_entries = 1000
        
        # Flask app setup
        self.app = Flask(__name__)
        CORS(self.app)  # Enable CORS for frontend
        self._setup_routes()
        
        # Background monitoring
        self.monitoring = True
        self.monitor_thread = None
    
    def _load_config(self, config_path: str) -> dict:
        """Load configuration from YAML file"""
        try:
            with open(config_path, 'r') as f:
                return yaml.safe_load(f)
        except FileNotFoundError:
            logging.error(f"Config file not found: {config_path}")
            return self._default_config()
    
    def _default_config(self) -> dict:
        return {
            'battery_device': 'BAT0',
            'max_charge': 80,
            'min_charge': 40,
            'check_interval': 60,
            'action_on_low': 'log',
            'log_level': 'INFO',
            'api_port': 5000,
            'api_host': '0.0.0.0'
        }
    
    def setup_logging(self):
        """Setup logging configuration"""
        log_level = getattr(logging, self.config.get('log_level', 'INFO'))
        logging.basicConfig(
            level=log_level,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
    
    def _setup_routes(self):
        """Setup Flask routes"""
        
        @self.app.route('/api/status', methods=['GET'])
        def get_status():
            """Get current battery and power status"""
            battery = self.get_battery_status()
            power = self.get_power_metrics()
            return jsonify({
                'battery': asdict(battery) if battery else None,
                'power': asdict(power) if power else None,
                'config': {
                    'max_charge': self.config.get('max_charge'),
                    'min_charge': self.config.get('min_charge'),
                    'battery_device': self.config.get('battery_device')
                }
            })
        
        @self.app.route('/api/battery', methods=['GET'])
        def get_battery():
            """Get detailed battery information"""
            battery = self.get_battery_status()
            return jsonify(asdict(battery) if battery else {})
        
        @self.app.route('/api/power', methods=['GET'])
        def get_power():
            """Get current power consumption metrics"""
            power = self.get_power_metrics()
            return jsonify(asdict(power) if power else {})
        
        @self.app.route('/api/history', methods=['GET'])
        def get_history():
            """Get historical battery and power data"""
            hours = request.args.get('hours', 24, type=int)
            cutoff_time = datetime.now() - timedelta(hours=hours)
            
            battery_data = [
                asdict(entry) for entry in self.battery_history
                if datetime.fromisoformat(entry.timestamp) > cutoff_time
            ]
            
            power_data = [
                asdict(entry) for entry in self.power_history
                if entry.timestamp and datetime.fromisoformat(entry.timestamp) > cutoff_time
            ]
            
            return jsonify({
                'battery_history': battery_data,
                'power_history': power_data
            })
        
        @self.app.route('/api/config', methods=['GET', 'POST'])
        def handle_config():
            """Get or update configuration"""
            if request.method == 'GET':
                return jsonify(self.config)
            
            elif request.method == 'POST':
                new_config = request.get_json()
                if not new_config:
                    return jsonify({'error': 'No configuration provided'}), 400
                
                # Validate and update config
                for key in ['max_charge', 'min_charge']:
                    if key in new_config:
                        value = new_config[key]
                        if not isinstance(value, int) or not (0 <= value <= 100):
                            return jsonify({'error': f'Invalid {key}: must be integer 0-100'}), 400
                        self.config[key] = value
                
                # Apply charge threshold if changed
                if 'max_charge' in new_config:
                    self._set_charge_threshold(new_config['max_charge'])
                
                return jsonify({'message': 'Configuration updated', 'config': self.config})
        
        @self.app.route('/api/health', methods=['GET'])
        def health_check():
            """Health check endpoint"""
            return jsonify({
                'status': 'healthy',
                'timestamp': datetime.now().isoformat(),
                'monitoring': self.monitoring
            })

    def get_battery_status(self) -> Optional[BatteryStatus]:
        """Get current battery status from sysfs"""
        device = self.config['battery_device']
        base_path = f"/sys/class/power_supply/{device}"
        
        if not os.path.exists(base_path):
            logging.error(f"Battery device {device} not found")
            return None
        
        try:
            # Read basic battery info
            capacity = self._read_sysfs_int(f"{base_path}/capacity")
            status = self._read_sysfs_str(f"{base_path}/status")
            
            # Read power-related values (microvolts/microamps/microwatts)
            voltage_now = self._read_sysfs_int(f"{base_path}/voltage_now")
            current_now = self._read_sysfs_int(f"{base_path}/current_now") 
            power_now = self._read_sysfs_int(f"{base_path}/power_now")
            energy_now = self._read_sysfs_int(f"{base_path}/energy_now")
            energy_full = self._read_sysfs_int(f"{base_path}/energy_full")
            
            # Read charge threshold
            threshold = self._read_sysfs_int(f"{base_path}/charge_control_end_threshold")
            
            # Convert microunits to standard units
            voltage_v = voltage_now / 1_000_000 if voltage_now else None
            current_a = current_now / 1_000_000 if current_now else None
            power_w = power_now / 1_000_000 if power_now else None
            energy_now_wh = energy_now / 1_000_000 if energy_now else None
            energy_full_wh = energy_full / 1_000_000 if energy_full else None
            
            # Calculate power if not directly available
            if not power_w and voltage_v and current_a:
                power_w = voltage_v * abs(current_a)
            
            return BatteryStatus(
                capacity=capacity,
                status=status,
                voltage_now=voltage_v,
                current_now=current_a,
                power_now=power_w,
                energy_now=energy_now_wh,
                energy_full=energy_full_wh,
                charge_control_end_threshold=threshold,
                timestamp=datetime.now().isoformat()
            )
            
        except Exception as e:
            logging.error(f"Error reading battery status: {e}")
            return None
    
    def get_power_metrics(self) -> Optional[PowerMetrics]:
        """Get system power consumption metrics"""
        try:
            cpu_power = self._get_cpu_power()
            gpu_power = self._get_gpu_power()
            
            # Try to get total system power from RAPL (Running Average Power Limit)
            total_power = self._get_rapl_power()
            
            return PowerMetrics(
                cpu_power=cpu_power,
                gpu_power=gpu_power,
                total_system_power=total_power,
                timestamp=datetime.now().isoformat()
            )
        except Exception as e:
            logging.error(f"Error getting power metrics: {e}")
            return None
    
    def _get_cpu_power(self) -> Optional[float]:
        """Get CPU power consumption from RAPL"""
        try:
            # Intel RAPL power monitoring
            rapl_paths = [
                "/sys/class/powercap/intel-rapl:0/energy_uj",
                "/sys/devices/virtual/powercap/intel-rapl/intel-rapl:0/energy_uj"
            ]
            
            for path in rapl_paths:
                if os.path.exists(path):
                    # Read energy twice with time interval to calculate power
                    energy1 = self._read_sysfs_int(path)
                    time.sleep(0.1)
                    energy2 = self._read_sysfs_int(path)
                    
                    if energy1 and energy2:
                        # Energy is in microjoules, convert to watts
                        energy_diff = (energy2 - energy1) / 1_000_000  # Convert to joules
                        power = energy_diff / 0.1  # Power = Energy / Time
                        return max(0, power)  # Ensure non-negative
            
            return None
        except Exception as e:
            logging.debug(f"Error reading CPU power: {e}")
            return None
    
    def _get_gpu_power(self) -> Optional[float]:
        """Get GPU power consumption"""
        try:
            # Try nvidia-smi for NVIDIA GPUs
            result = subprocess.run(
                ['nvidia-smi', '--query-gpu=power.draw', '--format=csv,noheader,nounits'],
                capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0:
                power_str = result.stdout.strip()
                return float(power_str) if power_str != '[Not Supported]' else None
        except:
            pass
        
        # Try AMD GPU power monitoring
        try:
            amd_power_path = "/sys/class/drm/card0/device/power1_average"
            if os.path.exists(amd_power_path):
                power_uw = self._read_sysfs_int(amd_power_path)
                return power_uw / 1_000_000 if power_uw else None
        except:
            pass
        
        return None
    
    def _get_rapl_power(self) -> Optional[float]:
        """Get total system power from RAPL"""
        try:
            # Try different RAPL package power paths
            rapl_paths = [
                "/sys/class/powercap/intel-rapl:0/power1_average",
                "/sys/devices/virtual/powercap/intel-rapl/intel-rapl:0/power1_average"
            ]
            
            for path in rapl_paths:
                if os.path.exists(path):
                    power_uw = self._read_sysfs_int(path)
                    return power_uw / 1_000_000 if power_uw else None
            
            return None
        except Exception as e:
            logging.debug(f"Error reading RAPL power: {e}")
            return None
    
    def _read_sysfs_int(self, path: str) -> Optional[int]:
        """Read integer value from sysfs file"""
        try:
            with open(path, 'r') as f:
                return int(f.read().strip())
        except (FileNotFoundError, ValueError, PermissionError):
            return None
    
    def _read_sysfs_str(self, path: str) -> Optional[str]:
        """Read string value from sysfs file"""
        try:
            with open(path, 'r') as f:
                return f.read().strip()
        except (FileNotFoundError, PermissionError):
            return None
    
    def _set_charge_threshold(self, threshold: int):
        """Set battery charge threshold"""
        device = self.config['battery_device']
        threshold_path = f"/sys/class/power_supply/{device}/charge_control_end_threshold"
        
        try:
            # Try direct write first
            with open(threshold_path, 'w') as f:
                f.write(str(threshold))
            logging.info(f"Set charge threshold to {threshold}%")
        except PermissionError:
            # Fall back to sudo tee method
            try:
                cmd = f"echo {threshold} | sudo tee {threshold_path}"
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                if result.returncode == 0:
                    logging.info(f"Set charge threshold to {threshold}% (via sudo)")
                else:
                    logging.error(f"Failed to set charge threshold: {result.stderr}")
            except Exception as e:
                logging.error(f"Error setting charge threshold: {e}")
    
    def monitor_loop(self):
        """Background monitoring loop"""
        while self.monitoring:
            try:
                # Get current status
                battery = self.get_battery_status()
                power = self.get_power_metrics()
                
                # Add to history
                if battery:
                    self.battery_history.append(battery)
                    if len(self.battery_history) > self.max_history_entries:
                        self.battery_history.pop(0)
                
                if power:
                    self.power_history.append(power)
                    if len(self.power_history) > self.max_history_entries:
                        self.power_history.pop(0)
                
                # Check thresholds and take action
                if battery:
                    self._check_thresholds(battery)
                
                time.sleep(self.config.get('check_interval', 60))
                
            except Exception as e:
                logging.error(f"Error in monitor loop: {e}")
                time.sleep(10)
    
    def _check_thresholds(self, battery: BatteryStatus):
        """Check battery thresholds and take action"""
        # Set charge threshold if needed
        max_charge = self.config.get('max_charge')
        if max_charge and battery.charge_control_end_threshold != max_charge:
            self._set_charge_threshold(max_charge)
        
        # Check minimum charge
        min_charge = self.config.get('min_charge')
        if min_charge and battery.capacity < min_charge:
            action = self.config.get('action_on_low', 'log')
            if action == 'log':
                logging.warning(f"Battery below minimum threshold: {battery.capacity}% < {min_charge}%")
            # Add other actions as needed
    
    def start_monitoring(self):
        """Start background monitoring thread"""
        if not self.monitor_thread or not self.monitor_thread.is_alive():
            self.monitoring = True
            self.monitor_thread = threading.Thread(target=self.monitor_loop, daemon=True)
            self.monitor_thread.start()
            logging.info("Started battery monitoring")
    
    def stop_monitoring(self):
        """Stop background monitoring"""
        self.monitoring = False
        if self.monitor_thread:
            self.monitor_thread.join(timeout=5)
        logging.info("Stopped battery monitoring")
    
    def run_api(self):
        """Run the Flask API server"""
        host = self.config.get('api_host', '0.0.0.0')
        port = self.config.get('api_port', 5000)
        debug = self.config.get('log_level', 'INFO') == 'DEBUG'
        
        logging.info(f"Starting Wattson API server on {host}:{port}")
        self.app.run(host=host, port=port, debug=debug)

def main():
    parser = argparse.ArgumentParser(description='Wattson Battery Management API')
    parser.add_argument('--config', default='config.yml', help='Config file path')
    parser.add_argument('--api-only', action='store_true', help='Run API server only (no monitoring)')
    args = parser.parse_args()
    
    wattson = WattsonAPI(args.config)
    
    if not args.api_only:
        wattson.start_monitoring()
    
    try:
        wattson.run_api()
    except KeyboardInterrupt:
        logging.info("Shutting down...")
    finally:
        wattson.stop_monitoring()

if __name__ == '__main__':
    main()